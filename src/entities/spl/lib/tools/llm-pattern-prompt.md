# SPL Command Pattern Generation Prompt

You are generating field lineage tracking patterns for Splunk SPL commands. These patterns define how commands affect fields in a search pipeline and are used for data lineage visualization.

---

## Output Format

Generate a valid JSON object conforming to the `CommandSyntax` interface. Your response must be parseable JSON.

---

## Excluded Fields (DO NOT GENERATE)

The following fields should **NOT** be generated by the LLM. They will be handled separately:

| Field | Reason | Default Value |
|-------|--------|---------------|
| `category` | Managed externally from command metadata | `""` (empty string) |

**Important:** Even if you have knowledge of a command's category, do NOT include it in your output. Set `category` to an empty string `""` in all generated patterns.

---

## Data Structures

### CommandSyntax (Main Output)

```typescript
interface CommandSyntax {
  command: string;                    // Command name lowercase (e.g., 'eval', 'stats')
  syntax: SyntaxPattern;              // Pattern tree defining command structure
  semantics?: CommandSemantics;       // Command-level field behaviors (optional)
  category?: string;                  // Category (e.g., 'fields::add', 'reporting')
  description?: string;               // Human-readable description
  examples?: string[];                // Usage examples
  related?: string[];                 // Related command names
  tags?: string[];                    // Search tags
}
```

### SyntaxPattern (Recursive Pattern Tree)

The pattern tree is built from these node types:

```typescript
type SyntaxPattern = TypedParam | Literal | Sequence | Alternation | Group;
```

#### TypedParam - Parameter Placeholder

Represents typed slots like `<field>`, `<int>`, etc.

```typescript
interface TypedParam {
  kind: 'param';
  type: ParamType;                    // See ParamType below
  name?: string;                      // Optional name for clarity
  quantifier?: '?' | '+' | '*' | '1'; // Optional(?) One+(+) Many(*) Exactly-one(1/default)
  effect?: FieldEffect;               // How this affects fields (CRITICAL for lineage)
  dependsOn?: string[];               // Field names this depends on
  dependsOnExpression?: string;       // AST property for expression analysis
}
```

#### Literal - Fixed Keyword or Symbol

Represents fixed strings like keywords and operators.

```typescript
interface Literal {
  kind: 'literal';
  value: string;                      // "as", "by", "=", "(", ")", etc.
  quantifier?: '?' | '+' | '*' | '1';
  caseInsensitive?: boolean;          // Default: true
}
```

#### Sequence - Ordered Patterns

Represents patterns that must appear in order: `A B C`

```typescript
interface Sequence {
  kind: 'sequence';
  patterns: SyntaxPattern[];          // Ordered list of sub-patterns
  quantifier?: '?' | '+' | '*' | '1';
}
```

#### Alternation - Choice Between Options

Represents choice: `A | B`

```typescript
interface Alternation {
  kind: 'alternation';
  options: SyntaxPattern[];           // List of alternative patterns
  quantifier?: '?' | '+' | '*' | '1';
}
```

#### Group - Grouping with Quantifier

Represents grouped patterns with repetition: `(A B)+`

```typescript
interface Group {
  kind: 'group';
  pattern: SyntaxPattern;             // The grouped pattern
  quantifier?: '?' | '+' | '*' | '1';
}
```

---

## ParamType Reference

| Type | Description | Example |
|------|-------------|---------|
| `field` | Single field name | `src_ip`, `_time` |
| `wc-field` | Wildcard field pattern | `foo*`, `*_time` |
| `field-list` | Comma-separated fields | `src, dst, port` |
| `evaled-field` | Eval expression | `a+b`, `upper(name)` |
| `int` | Integer value | `10`, `100` |
| `num` | Number (int or float) | `3.14`, `100` |
| `string` | String literal | `"error"`, `'warning'` |
| `bool` | Boolean value | `true`, `false` |
| `stats-func` | Aggregation function | `count`, `avg`, `sum` |
| `time-modifier` | Time specifier | `-24h`, `@d`, `+1w` |

---

## FieldEffect Reference (Critical for Lineage)

This is the most important property for field lineage tracking. Only add `effect` to parameters that represent field names.

| Effect | When to Use | Examples |
|--------|-------------|----------|
| `creates` | Command produces a NEW field | `eval total=a+b` creates `total` |
| `consumes` | Command READS an existing field | `where status=200` consumes `status` |
| `modifies` | Command CHANGES a field in-place | `bin _time` modifies `_time` |
| `groups-by` | Field used in BY clause for grouping | `stats count BY host` |
| `drops` | Command REMOVES a field | `fields - password` drops `password` |

---

## CommandSemantics Reference

Use semantics for command-level field behaviors that can't be expressed per-parameter.

```typescript
interface CommandSemantics {
  // Commands like stats/chart DROP all fields except these
  dropsAllExcept?: ('byFields' | 'creates')[];

  // Commands like eventstats/streamstats PRESERVE all fields
  preservesAll?: boolean;

  // Different behavior per variant (stats vs eventstats share syntax)
  variantRules?: {
    [variant: string]: Partial<CommandSemantics>;
  };
}
```

### When to use semantics:

| Semantic | Use Case | Commands |
|----------|----------|----------|
| `dropsAllExcept: ['byFields', 'creates']` | Aggregation drops all except BY fields and created aggregations | `stats`, `chart`, `timechart` |
| `preservesAll: true` | Command adds fields but keeps all existing | `eventstats`, `streamstats`, `addtotals` |
| `variantRules` | Same syntax, different field behavior | stats family |

---

## Quantifier Reference

| Symbol | Meaning | Example |
|--------|---------|---------|
| `?` | Optional (zero or one) | `(AS <field>)?` - optional alias |
| `+` | One or more | `(<field>)+` - at least one field |
| `*` | Zero or more | `(<option>)*` - any number of options |
| `1` | Exactly one (default, can omit) | `<field>` - required field |

---

## Pattern Examples

### Example 1: Simple Field Creator (eval)

**Command:** `eval`
**Syntax:** `eval <field>=<expression> [, <field>=<expression>]...`

```json
{
  "command": "eval",
  "syntax": {
    "kind": "group",
    "quantifier": "+",
    "pattern": {
      "kind": "sequence",
      "patterns": [
        { "kind": "param", "type": "field", "effect": "creates", "name": "targetField" },
        { "kind": "literal", "value": "=" },
        { "kind": "param", "type": "evaled-field", "name": "expression", "dependsOnExpression": "expression" }
      ]
    }
  },
  "category": "",
  "description": "Calculates an expression and puts the resulting value into a new field.",
  "examples": ["eval total=price*quantity", "eval status=if(code>=400, \"error\", \"ok\")"],
  "related": ["where", "case"],
  "tags": ["calculate", "expression", "field"]
}
```

### Example 2: Field Renamer (rename)

**Command:** `rename`
**Syntax:** `rename <wc-field> AS <wc-field> [, <wc-field> AS <wc-field>]...`

```json
{
  "command": "rename",
  "syntax": {
    "kind": "group",
    "quantifier": "+",
    "pattern": {
      "kind": "sequence",
      "patterns": [
        { "kind": "param", "type": "wc-field", "effect": "consumes", "name": "oldField" },
        { "kind": "literal", "value": "as" },
        { "kind": "param", "type": "wc-field", "effect": "creates", "name": "newField" }
      ]
    }
  },
  "category": "",
  "description": "Renames a field. The original field is removed and a new field is created.",
  "examples": ["rename _ip as src_ip", "rename *_old as *_new"],
  "related": ["fields", "table"],
  "tags": ["rename", "alias"]
}
```

### Example 3: Aggregation with Semantics (stats)

**Command:** `stats`
**Syntax:** `stats <stats-func>(<field>) [AS <field>] [BY <field-list>]`

```json
{
  "command": "stats",
  "syntax": {
    "kind": "sequence",
    "patterns": [
      {
        "kind": "group",
        "quantifier": "+",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            { "kind": "param", "type": "stats-func", "name": "function" },
            { "kind": "literal", "value": "(" },
            { "kind": "param", "type": "field", "effect": "consumes", "quantifier": "?" },
            { "kind": "literal", "value": ")" },
            {
              "kind": "group",
              "quantifier": "?",
              "pattern": {
                "kind": "sequence",
                "patterns": [
                  { "kind": "literal", "value": "as" },
                  { "kind": "param", "type": "field", "effect": "creates", "name": "alias" }
                ]
              }
            }
          ]
        }
      },
      {
        "kind": "group",
        "quantifier": "?",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            { "kind": "literal", "value": "by" },
            { "kind": "param", "type": "field-list", "effect": "groups-by", "name": "byFields" }
          ]
        }
      }
    ]
  },
  "semantics": {
    "dropsAllExcept": ["byFields", "creates"],
    "variantRules": {
      "stats": { "dropsAllExcept": ["byFields", "creates"] },
      "chart": { "dropsAllExcept": ["byFields", "creates"] },
      "timechart": { "dropsAllExcept": ["byFields", "creates"] },
      "eventstats": { "preservesAll": true },
      "streamstats": { "preservesAll": true }
    }
  },
  "category": "",
  "description": "Calculates aggregate statistics over results.",
  "examples": ["stats count by host", "stats avg(duration) as avg_dur by src_ip"],
  "related": ["eventstats", "streamstats", "chart"],
  "tags": ["aggregate", "statistics", "count", "sum", "avg"]
}
```

### Example 4: Field Filter (fields)

**Command:** `fields`
**Syntax:** `fields [+|-] <field-list>`

```json
{
  "command": "fields",
  "syntax": {
    "kind": "sequence",
    "patterns": [
      {
        "kind": "group",
        "quantifier": "?",
        "pattern": {
          "kind": "alternation",
          "options": [
            { "kind": "literal", "value": "+" },
            { "kind": "literal", "value": "-" }
          ]
        }
      },
      { "kind": "param", "type": "field-list", "effect": "consumes", "name": "fieldList" }
    ]
  },
  "category": "",
  "description": "Keeps or removes fields from search results.",
  "examples": ["fields host, source, _time", "fields - _raw, _indextime"],
  "related": ["table", "rename"],
  "tags": ["filter", "select", "remove"]
}
```

### Example 5: In-Place Modifier (bin)

**Command:** `bin`
**Syntax:** `bin [<bin-options>] <field> [AS <field>]`

```json
{
  "command": "bin",
  "syntax": {
    "kind": "sequence",
    "patterns": [
      {
        "kind": "group",
        "quantifier": "*",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            { "kind": "param", "type": "string", "name": "optionName" },
            { "kind": "literal", "value": "=" },
            { "kind": "param", "type": "string", "name": "optionValue" }
          ]
        }
      },
      { "kind": "param", "type": "field", "effect": "modifies", "name": "targetField" },
      {
        "kind": "group",
        "quantifier": "?",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            { "kind": "literal", "value": "as" },
            { "kind": "param", "type": "field", "effect": "creates", "name": "alias" }
          ]
        }
      }
    ]
  },
  "category": "",
  "description": "Puts continuous numerical values into discrete sets or bins.",
  "examples": ["bin _time span=1h", "bin _time span=5m as time_bucket"],
  "related": ["bucket", "timechart"],
  "tags": ["bin", "bucket", "discretize"]
}
```

### Example 6: Lookup with Output Fields

**Command:** `lookup`
**Syntax:** `lookup <lookup-table> <field-list> [OUTPUT|OUTPUTNEW <field-list>]`

```json
{
  "command": "lookup",
  "syntax": {
    "kind": "sequence",
    "patterns": [
      { "kind": "param", "type": "string", "name": "lookupName" },
      { "kind": "param", "type": "field-list", "effect": "consumes", "name": "inputFields" },
      {
        "kind": "group",
        "quantifier": "?",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            {
              "kind": "alternation",
              "options": [
                { "kind": "literal", "value": "OUTPUT" },
                { "kind": "literal", "value": "OUTPUTNEW" }
              ]
            },
            { "kind": "param", "type": "field-list", "effect": "creates", "name": "outputFields" }
          ]
        }
      }
    ]
  },
  "category": "",
  "description": "Enriches events with fields from a lookup table.",
  "examples": [
    "lookup users user_id OUTPUT user_name, department",
    "lookup geo_ip src_ip OUTPUTNEW city, country"
  ],
  "related": ["inputlookup", "outputlookup"],
  "tags": ["lookup", "enrich", "join"]
}
```

### Example 7: No Field Effect (simple command)

**Command:** `reverse`
**Syntax:** `reverse`

```json
{
  "command": "reverse",
  "syntax": {
    "kind": "literal",
    "value": "reverse"
  },
  "category": "",
  "description": "Reverses the order of search results.",
  "examples": ["... | reverse"],
  "related": ["sort", "head", "tail"],
  "tags": ["order", "reverse"]
}
```

### Example 8: Rex with Named Capture Groups

**Command:** `rex`
**Syntax:** `rex [field=<field>] <regex-pattern>`

```json
{
  "command": "rex",
  "syntax": {
    "kind": "sequence",
    "patterns": [
      {
        "kind": "group",
        "quantifier": "?",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            { "kind": "literal", "value": "field" },
            { "kind": "literal", "value": "=" },
            { "kind": "param", "type": "field", "effect": "consumes", "name": "sourceField" }
          ]
        }
      },
      { "kind": "param", "type": "string", "name": "pattern" }
    ]
  },
  "category": "",
  "description": "Extracts fields using regular expression named capture groups.",
  "examples": [
    "rex field=_raw \"user=(?<username>\\w+)\"",
    "rex \"(?<src_ip>\\d+\\.\\d+\\.\\d+\\.\\d+)\""
  ],
  "related": ["extract", "erex"],
  "tags": ["regex", "extract", "parse"]
}
```

---

## Decision Tree: Determining Field Effects

Use this decision tree to determine if and what `effect` to assign:

```
Does the parameter represent a FIELD NAME (not a value, option, or pattern)?
│
├── NO → Do NOT add an effect property
│   Examples: span=1h (option value), "regex" (pattern), 100 (limit)
│
└── YES → Determine the effect type:
    │
    ├── Is this field being CREATED by the command?
    │   Examples: eval target=..., AS alias, lookup OUTPUT fields
    │   └── effect: 'creates'
    │
    ├── Is this field being READ/referenced?
    │   Examples: where field=value, sort field, stats count(field)
    │   └── effect: 'consumes'
    │
    ├── Is this field being CHANGED in-place?
    │   Examples: bin _time, fillnull value=0 field
    │   └── effect: 'modifies'
    │
    ├── Is this a BY clause field?
    │   Examples: stats ... BY field, chart ... BY field
    │   └── effect: 'groups-by'
    │
    └── Is this field being REMOVED?
        Examples: fields - field
        └── effect: 'drops'
```

---

## Commands That May Have No Field Effects

These command categories typically don't need field effects:

| Category | Examples | Reason |
|----------|----------|--------|
| Display/formatting | `preview`, `highlight`, `iconify` | Visual only |
| Metadata | `audit`, `history`, `metadata` | System info |
| Job control | `localop`, `loadjob`, `sendemail` | Infrastructure |
| Output | `outputraw`, `outputtext` | Raw output |

**For these commands, return a minimal pattern WITHOUT effect properties:**

```json
{
  "command": "preview",
  "syntax": { "kind": "literal", "value": "preview" },
  "category": "",
  "description": "Shows a preview of search results."
}
```

---

## Common Patterns

### Optional Named Parameter
```json
{
  "kind": "group",
  "quantifier": "?",
  "pattern": {
    "kind": "sequence",
    "patterns": [
      { "kind": "literal", "value": "span" },
      { "kind": "literal", "value": "=" },
      { "kind": "param", "type": "time-modifier", "name": "span" }
    ]
  }
}
```

### One or More with Separator (comma-separated)
```json
{
  "kind": "group",
  "quantifier": "+",
  "pattern": {
    "kind": "sequence",
    "patterns": [
      { "kind": "param", "type": "field", "effect": "consumes" },
      { "kind": "group", "quantifier": "?", "pattern": { "kind": "literal", "value": "," } }
    ]
  }
}
```

### Alternation (choice)
```json
{
  "kind": "alternation",
  "options": [
    { "kind": "literal", "value": "OUTPUT" },
    { "kind": "literal", "value": "OUTPUTNEW" }
  ]
}
```

### Optional AS Alias
```json
{
  "kind": "group",
  "quantifier": "?",
  "pattern": {
    "kind": "sequence",
    "patterns": [
      { "kind": "literal", "value": "as" },
      { "kind": "param", "type": "field", "effect": "creates", "name": "alias" }
    ]
  }
}
```

### BY Clause
```json
{
  "kind": "group",
  "quantifier": "?",
  "pattern": {
    "kind": "sequence",
    "patterns": [
      { "kind": "literal", "value": "by" },
      { "kind": "param", "type": "field-list", "effect": "groups-by", "name": "byFields" }
    ]
  }
}
```

---

## AST-Alignment Guidelines

Patterns should align with the AST (Abstract Syntax Tree) structure produced by the parser, not just the raw BNF syntax. This means:

### Focus on Field Lineage, Not Syntax Details

The pattern's primary purpose is **field lineage tracking**, not syntax validation. Include:
- Parameters that represent **field names** (with appropriate `effect`)
- Command options that **affect field behavior** (e.g., `fieldname=` creates a field)
- Semantic behaviors (`dropsAllExcept`, `preservesAll`)

### Simplify Non-Field Options

For command options that don't affect fields, use a simplified pattern:
```json
{
  "kind": "group",
  "quantifier": "*",
  "pattern": {
    "kind": "sequence",
    "patterns": [
      { "kind": "param", "type": "string", "name": "optionName" },
      { "kind": "literal", "value": "=" },
      { "kind": "param", "type": "string", "name": "optionValue" }
    ]
  }
}
```

### Named Options That Create/Consume Fields

When a named option references a field, include it with the appropriate effect:
```json
{
  "kind": "sequence",
  "patterns": [
    { "kind": "literal", "value": "fieldname" },
    { "kind": "literal", "value": "=" },
    { "kind": "param", "type": "field", "effect": "creates", "name": "fieldname" }
  ]
}
```

### Use `dependsOn` for Field Relationships

When a created field depends on other fields in the same command:
```json
{
  "kind": "param",
  "type": "field",
  "effect": "creates",
  "name": "newField",
  "dependsOn": ["sourceField"]
}
```

### Aggregation Functions

For stats-style commands, the aggregation structure should capture:
1. The function name (informational, no effect)
2. The input field (`consumes`)
3. The output/alias field (`creates` with `dependsOn`)

```json
{
  "kind": "group",
  "quantifier": "+",
  "pattern": {
    "kind": "sequence",
    "patterns": [
      { "kind": "param", "type": "stats-func", "name": "function" },
      { "kind": "literal", "value": "(" },
      { "kind": "param", "type": "field", "effect": "consumes", "name": "inputField", "quantifier": "?" },
      { "kind": "literal", "value": ")" },
      {
        "kind": "group",
        "quantifier": "?",
        "pattern": {
          "kind": "sequence",
          "patterns": [
            { "kind": "literal", "value": "as" },
            { "kind": "param", "type": "field", "effect": "creates", "name": "outputField", "dependsOn": ["inputField"] }
          ]
        }
      }
    ]
  }
}
```

---

## Validation Checklist

Before submitting your pattern, verify:

- [ ] `command` is lowercase
- [ ] `category` is set to empty string `""`
- [ ] All field parameters have appropriate `effect` (or no effect if not a field)
- [ ] Quantifiers are correct (`?` for optional, `+` for one-or-more, `*` for zero-or-more)
- [ ] `semantics` included if command has special field lifecycle (aggregations, etc.)
- [ ] JSON is valid and parseable
- [ ] Pattern focuses on field lineage, not syntax validation
- [ ] `dependsOn` used for field relationships within the command

---

## Your Task

Given the following SPL command information, generate a `CommandSyntax` JSON object:

**Command:** `{{COMMAND_NAME}}`
**BNF Syntax:** `{{BNF_SYNTAX}}`
**Description:** `{{DESCRIPTION}}`
**Examples:** `{{EXAMPLES}}`

Generate the pattern following these rules:
1. Parse the BNF syntax into a pattern tree
2. Add `effect` ONLY to parameters representing field names
3. Add `semantics` if the command has special field lifecycle behavior
4. Set `category` to empty string `""` (DO NOT generate a category value)
5. Include other metadata (description, examples, related, tags)
6. Return valid JSON only

**Response format:** Return only the JSON object, no explanation or markdown code blocks.

---

## Post-Processing Workflow

After receiving LLM-generated patterns, the following post-processing steps should be applied:

### 1. Category Assignment
The `category` field is **NOT** generated by the LLM. Categories should be assigned from:
- Existing command metadata (if updating patterns)
- Manual classification

### 2. Validation
Run generated patterns through the pattern validator:
```typescript
import { validateCommandSyntax } from './patterns/validator';
const result = validateCommandSyntax(pattern);
```

### 3. Registry Integration
Add validated patterns to the registry:
```typescript
import { COMMAND_PATTERNS } from './patterns/registry';
COMMAND_PATTERNS[pattern.command] = pattern;
```

### 4. Fields to Preserve (Not Overwrite)
When updating existing patterns, preserve these fields from the original:
- `category` - Keep original value or set to `""`

### 5. Fields to Update from LLM
- `syntax` - Pattern tree (primary LLM output)
- `semantics` - Field lifecycle behavior
- `description` - Human-readable description
- `examples` - Usage examples
- `related` - Related commands
- `tags` - Search tags
